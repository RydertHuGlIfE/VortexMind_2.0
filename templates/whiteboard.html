<!DOCTYPE html>
<html>

<head>
    <title>Whiteboard - VortexMind Educator</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='input.css') }}" />
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap"
        rel="stylesheet" />
    <link rel="icon" type="image/x-icon" href="{{ url_for('static', filename='favico.ico') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='whiteboard.css') }}" />
</head>

<body>
    <!-- Header -->
    <header class="header">
        <div class="header-left">
            <div class="logo">
                <div class="logo-icon">üé®</div>
                <div class="logo-text">
                    <h1>Whiteboard</h1>
                    <p>Creative Canvas</p>
                </div>
            </div>
        </div>
        <div class="header-center">
            <div class="status-indicator">
                <span class="status-dot"></span>
                <span>Drawing Mode</span>
            </div>
        </div>
        <div class="header-right">
            <button id="themeToggle" class="theme-toggle" aria-label="Toggle theme">
                <span class="theme-icon">üåô</span>
            </button>
        </div>
    </header>

    <!-- Back Button -->
    <a href="/" class="back-btn">
        <span>‚Üê</span> Back to Home
    </a>

    <!-- Whiteboard Container -->
    <div class="whiteboard-container">
        <!-- Main Toolbar -->
        <div class="toolbar-wrapper">
            <!-- Drawing Tools -->
            <div class="toolbar">
                <span class="toolbar-label">Tools</span>
                <button class="tool-btn active" data-tool="pen" data-tooltip="Pen (P)">‚úèÔ∏è</button>
                <button class="tool-btn" data-tool="highlighter" data-tooltip="Highlighter (H)">üñåÔ∏è</button>
                <button class="tool-btn" data-tool="eraser" data-tooltip="Eraser (E)">üßΩ</button>
                <button class="tool-btn" data-tool="text" data-tooltip="Text (T)">üìù</button>

                <div class="toolbar-divider"></div>

                <!-- Shapes -->
                <div class="shape-dropdown">
                    <button class="tool-btn" data-tool="shape" data-tooltip="Shapes (S)">‚¨ú</button>
                    <div class="shape-menu" id="shapeMenu">
                        <button class="shape-option" data-shape="line">üìè</button>
                        <button class="shape-option" data-shape="rectangle">‚¨ú</button>
                        <button class="shape-option" data-shape="circle">‚≠ï</button>
                        <button class="shape-option" data-shape="triangle">üî∫</button>
                        <button class="shape-option" data-shape="arrow">‚û°Ô∏è</button>
                        <button class="shape-option" data-shape="star">‚≠ê</button>
                    </div>
                </div>

                <button class="tool-btn" data-tool="fill" data-tooltip="Fill (F)">ü™£</button>
            </div>

            <!-- Pen Colors -->
            <div class="toolbar">
                <span class="toolbar-label">Colors</span>
                <button class="pen-btn pen-black active" data-color="#1a1a2e" data-tooltip="Black"></button>
                <button class="pen-btn pen-red" data-color="#ef4444" data-tooltip="Red"></button>
                <button class="pen-btn pen-blue" data-color="#3b82f6" data-tooltip="Blue"></button>
                <button class="pen-btn pen-green" data-color="#22c55e" data-tooltip="Green"></button>
                <button class="pen-btn pen-yellow" data-color="#eab308" data-tooltip="Yellow"></button>
                <button class="pen-btn pen-purple" data-color="#a855f7" data-tooltip="Purple"></button>
                <button class="pen-btn pen-orange" data-color="#f97316" data-tooltip="Orange"></button>
                <button class="pen-btn pen-pink" data-color="#ec4899" data-tooltip="Pink"></button>

                <div class="color-picker-wrapper">
                    <button class="color-picker-btn" data-tooltip="Custom Color"></button>
                    <input type="color" id="customColorPicker" value="#a855f7">
                </div>
            </div>

            <!-- Size & Opacity -->
            <div class="toolbar">
                <span class="toolbar-label">Size</span>
                <div class="size-slider-container">
                    <div class="size-preview">
                        <div class="size-dot" id="sizePreview"></div>
                    </div>
                    <input type="range" class="size-slider" id="brushSize" min="1" max="50" value="4">
                </div>

                <div class="opacity-control" id="opacityControl">
                    <span class="toolbar-label">Opacity</span>
                    <input type="range" class="opacity-slider" id="brushOpacity" min="10" max="100" value="40">
                </div>
            </div>

            <!-- Actions -->
            <div class="toolbar">
                <button class="action-btn" id="undoBtn" data-tooltip="Undo (Ctrl+Z)">
                    <span>‚Ü©Ô∏è</span> Undo
                </button>
                <button class="action-btn" id="redoBtn" data-tooltip="Redo (Ctrl+Y)">
                    <span>‚Ü™Ô∏è</span> Redo
                </button>
                <button class="action-btn danger" id="clearBtn" data-tooltip="Clear All">
                    <span>üóëÔ∏è</span> Clear
                </button>
                <button class="action-btn success" id="downloadBtn" data-tooltip="Save as PNG">
                    <span>üíæ</span> Save
                </button>
                <button class="action-btn" id="canvasModeBtn" data-tooltip="Toggle Dark/Light Canvas">
                    <span>üåì</span>
                </button>
            </div>
        </div>

        <!-- Canvas -->
        <div class="canvas-container" id="canvasContainer">
            <canvas id="whiteboard"></canvas>
        </div>

        <!-- Status Bar -->
        <div class="status-bar">
            <div class="status-item">
                <span>Tool:</span>
                <span class="status-value" id="currentTool">Pen</span>
            </div>
            <div class="status-item">
                <span>Color:</span>
                <span class="status-value" id="currentColor">#1a1a2e</span>
            </div>
            <div class="status-item">
                <span>Size:</span>
                <span class="status-value" id="currentSize">4px</span>
            </div>
            <div class="status-item">
                <span>Canvas:</span>
                <span class="status-value" id="canvasSize">Loading...</span>
            </div>
        </div>
    </div>

    <script>
        // Canvas Setup
        const canvas = document.getElementById('whiteboard');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('canvasContainer');

        // State
        let isDrawing = false;
        let currentTool = 'pen';
        let currentColor = '#1a1a2e';
        let brushSize = 4;
        let brushOpacity = 0.4;
        let lastX, lastY;
        let startX, startY;
        let currentShape = 'rectangle';
        let isDarkCanvas = false;

        // History for undo/redo
        let history = [];
        let historyIndex = -1;
        const maxHistory = 50;

        // Initialize canvas
        function initCanvas() {
            const containerRect = container.getBoundingClientRect();
            const padding = 40;
            canvas.width = Math.min(containerRect.width - padding, 1400);
            canvas.height = Math.min(containerRect.height - padding, 900);

            // Fill with white background
            ctx.fillStyle = isDarkCanvas ? '#1a1a2e' : '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Save initial state
            saveState();

            // Update status
            document.getElementById('canvasSize').textContent = `${canvas.width} √ó ${canvas.height}`;
        }

        // Save canvas state for undo/redo
        function saveState() {
            // Remove any redo states
            if (historyIndex < history.length - 1) {
                history = history.slice(0, historyIndex + 1);
            }

            // Add current state
            history.push(canvas.toDataURL());

            // Limit history size
            if (history.length > maxHistory) {
                history.shift();
            } else {
                historyIndex++;
            }
        }

        // Undo
        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                loadState(history[historyIndex]);
            }
        }

        // Redo
        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                loadState(history[historyIndex]);
            }
        }

        // Load state from history
        function loadState(dataUrl) {
            const img = new Image();
            img.onload = () => {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0);
            };
            img.src = dataUrl;
        }

        // Get coordinates
        function getCoords(e) {
            const rect = canvas.getBoundingClientRect();
            if (e.touches) {
                return {
                    x: e.touches[0].clientX - rect.left,
                    y: e.touches[0].clientY - rect.top
                };
            }
            return {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
        }

        // Start drawing
        function startDrawing(e) {
            e.preventDefault();
            isDrawing = true;
            const coords = getCoords(e);
            lastX = coords.x;
            lastY = coords.y;
            startX = coords.x;
            startY = coords.y;

            if (currentTool === 'text') {
                addText(coords.x, coords.y);
                isDrawing = false;
            } else if (currentTool === 'fill') {
                floodFill(Math.floor(coords.x), Math.floor(coords.y), currentColor);
                saveState();
                isDrawing = false;
            }
        }

        // Draw
        function draw(e) {
            if (!isDrawing) return;
            e.preventDefault();

            const coords = getCoords(e);

            if (currentTool === 'pen' || currentTool === 'highlighter' || currentTool === 'eraser') {
                ctx.beginPath();
                ctx.moveTo(lastX, lastY);
                ctx.lineTo(coords.x, coords.y);

                if (currentTool === 'eraser') {
                    ctx.strokeStyle = isDarkCanvas ? '#1a1a2e' : '#ffffff';
                    ctx.globalAlpha = 1;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.lineWidth = brushSize * 3;
                } else if (currentTool === 'highlighter') {
                    ctx.strokeStyle = currentColor;
                    ctx.globalAlpha = brushOpacity;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.lineWidth = brushSize * 4;
                } else {
                    ctx.strokeStyle = currentColor;
                    ctx.globalAlpha = 1;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.lineWidth = brushSize;
                }

                ctx.stroke();
                ctx.globalAlpha = 1;

                lastX = coords.x;
                lastY = coords.y;
            } else if (currentTool === 'shape') {
                // Preview shape while drawing
                loadState(history[historyIndex]);
                drawShape(startX, startY, coords.x, coords.y, true);
            }
        }

        // Stop drawing
        function stopDrawing(e) {
            if (!isDrawing) return;

            if (currentTool === 'shape') {
                const coords = getCoords(e);
                drawShape(startX, startY, coords.x, coords.y, false);
            }

            isDrawing = false;
            saveState();
        }

        // Draw shape
        function drawShape(x1, y1, x2, y2, isPreview = false) {
            ctx.beginPath();
            ctx.strokeStyle = currentColor;
            ctx.fillStyle = currentColor;
            ctx.lineWidth = brushSize;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            const width = x2 - x1;
            const height = y2 - y1;

            switch (currentShape) {
                case 'line':
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                    break;

                case 'rectangle':
                    ctx.strokeRect(x1, y1, width, height);
                    break;

                case 'circle':
                    const radius = Math.sqrt(width * width + height * height) / 2;
                    const centerX = x1 + width / 2;
                    const centerY = y1 + height / 2;
                    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                    ctx.stroke();
                    break;

                case 'triangle':
                    ctx.moveTo(x1 + width / 2, y1);
                    ctx.lineTo(x1, y2);
                    ctx.lineTo(x2, y2);
                    ctx.closePath();
                    ctx.stroke();
                    break;

                case 'arrow':
                    const angle = Math.atan2(height, width);
                    const headLen = Math.min(20, Math.sqrt(width * width + height * height) * 0.3);

                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.lineTo(x2 - headLen * Math.cos(angle - Math.PI / 6), y2 - headLen * Math.sin(angle - Math.PI / 6));
                    ctx.moveTo(x2, y2);
                    ctx.lineTo(x2 - headLen * Math.cos(angle + Math.PI / 6), y2 - headLen * Math.sin(angle + Math.PI / 6));
                    ctx.stroke();
                    break;

                case 'star':
                    const cx = x1 + width / 2;
                    const cy = y1 + height / 2;
                    const outerRadius = Math.abs(width) / 2;
                    const innerRadius = outerRadius / 2;
                    const spikes = 5;

                    for (let i = 0; i < spikes * 2; i++) {
                        const r = i % 2 === 0 ? outerRadius : innerRadius;
                        const a = (i * Math.PI / spikes) - Math.PI / 2;
                        const px = cx + r * Math.cos(a);
                        const py = cy + r * Math.sin(a);

                        if (i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                    ctx.stroke();
                    break;
            }
        }

        // Add text
        function addText(x, y) {
            const text = prompt('Enter text:');
            if (text) {
                ctx.font = `${brushSize * 4}px Inter, sans-serif`;
                ctx.fillStyle = currentColor;
                ctx.fillText(text, x, y);
                saveState();
            }
        }

        // Flood fill algorithm
        function floodFill(startX, startY, fillColor) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            const startIdx = (startY * canvas.width + startX) * 4;
            const startR = data[startIdx];
            const startG = data[startIdx + 1];
            const startB = data[startIdx + 2];

            // Convert hex to RGB
            const fillR = parseInt(fillColor.slice(1, 3), 16);
            const fillG = parseInt(fillColor.slice(3, 5), 16);
            const fillB = parseInt(fillColor.slice(5, 7), 16);

            // Don't fill if same color
            if (startR === fillR && startG === fillG && startB === fillB) return;

            const stack = [[startX, startY]];
            const tolerance = 32;

            function colorMatch(idx) {
                return Math.abs(data[idx] - startR) <= tolerance &&
                    Math.abs(data[idx + 1] - startG) <= tolerance &&
                    Math.abs(data[idx + 2] - startB) <= tolerance;
            }

            while (stack.length > 0) {
                const [x, y] = stack.pop();
                const idx = (y * canvas.width + x) * 4;

                if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height) continue;
                if (!colorMatch(idx)) continue;

                data[idx] = fillR;
                data[idx + 1] = fillG;
                data[idx + 2] = fillB;
                data[idx + 3] = 255;

                stack.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
            }

            ctx.putImageData(imageData, 0, 0);
        }

        // Clear canvas
        function clearCanvas() {
            if (confirm('Are you sure you want to clear the canvas?')) {
                ctx.fillStyle = isDarkCanvas ? '#1a1a2e' : '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                saveState();
            }
        }

        // Download canvas
        function downloadCanvas() {
            const link = document.createElement('a');
            link.download = `whiteboard-${Date.now()}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        // Toggle canvas mode
        function toggleCanvasMode() {
            isDarkCanvas = !isDarkCanvas;
            canvas.classList.toggle('dark-canvas', isDarkCanvas);

            // Redraw with new background
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            tempCanvas.getContext('2d').drawImage(canvas, 0, 0);

            ctx.fillStyle = isDarkCanvas ? '#1a1a2e' : '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(tempCanvas, 0, 0);
        }

        // Event Listeners
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);

        // Touch support
        canvas.addEventListener('touchstart', startDrawing, { passive: false });
        canvas.addEventListener('touchmove', draw, { passive: false });
        canvas.addEventListener('touchend', stopDrawing);

        // Tool buttons
        document.querySelectorAll('.tool-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                if (btn.dataset.tool === 'shape') {
                    const menu = document.getElementById('shapeMenu');
                    menu.classList.toggle('show');
                    return;
                }

                document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentTool = btn.dataset.tool;
                document.getElementById('currentTool').textContent = currentTool.charAt(0).toUpperCase() + currentTool.slice(1);

                // Show/hide opacity control for highlighter
                document.getElementById('opacityControl').classList.toggle('show', currentTool === 'highlighter');

                // Hide shape menu
                document.getElementById('shapeMenu').classList.remove('show');
            });
        });

        // Shape options
        document.querySelectorAll('.shape-option').forEach(opt => {
            opt.addEventListener('click', () => {
                document.querySelectorAll('.shape-option').forEach(o => o.classList.remove('active'));
                opt.classList.add('active');
                currentShape = opt.dataset.shape;
                currentTool = 'shape';

                document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                document.querySelector('[data-tool="shape"]').classList.add('active');
                document.getElementById('currentTool').textContent = `Shape: ${currentShape}`;
                document.getElementById('shapeMenu').classList.remove('show');
            });
        });

        // Pen color buttons
        document.querySelectorAll('.pen-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.pen-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentColor = btn.dataset.color;
                document.getElementById('currentColor').textContent = currentColor;
            });
        });

        // Custom color picker
        const colorPicker = document.getElementById('customColorPicker');
        document.querySelector('.color-picker-btn').addEventListener('click', () => colorPicker.click());
        colorPicker.addEventListener('input', (e) => {
            currentColor = e.target.value;
            document.querySelectorAll('.pen-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('currentColor').textContent = currentColor;
        });

        // Brush size slider
        const sizeSlider = document.getElementById('brushSize');
        const sizePreview = document.getElementById('sizePreview');
        sizeSlider.addEventListener('input', (e) => {
            brushSize = parseInt(e.target.value);
            sizePreview.style.width = `${Math.min(brushSize, 24)}px`;
            sizePreview.style.height = `${Math.min(brushSize, 24)}px`;
            document.getElementById('currentSize').textContent = `${brushSize}px`;
        });
        // Initialize preview
        sizePreview.style.width = '4px';
        sizePreview.style.height = '4px';

        // Brush opacity slider
        document.getElementById('brushOpacity').addEventListener('input', (e) => {
            brushOpacity = parseInt(e.target.value) / 100;
        });

        // Action buttons
        document.getElementById('undoBtn').addEventListener('click', undo);
        document.getElementById('redoBtn').addEventListener('click', redo);
        document.getElementById('clearBtn').addEventListener('click', clearCanvas);
        document.getElementById('downloadBtn').addEventListener('click', downloadCanvas);
        document.getElementById('canvasModeBtn').addEventListener('click', toggleCanvasMode);

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 'z') {
                e.preventDefault();
                undo();
            } else if (e.ctrlKey && e.key === 'y') {
                e.preventDefault();
                redo();
            } else if (e.key === 'p') {
                document.querySelector('[data-tool="pen"]').click();
            } else if (e.key === 'e') {
                document.querySelector('[data-tool="eraser"]').click();
            } else if (e.key === 'h') {
                document.querySelector('[data-tool="highlighter"]').click();
            } else if (e.key === 't') {
                document.querySelector('[data-tool="text"]').click();
            } else if (e.key === 's' && !e.ctrlKey) {
                document.querySelector('[data-tool="shape"]').click();
            } else if (e.key === 'f') {
                document.querySelector('[data-tool="fill"]').click();
            }
        });

        // Close shape menu on outside click
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.shape-dropdown')) {
                document.getElementById('shapeMenu').classList.remove('show');
            }
        });

        // Theme Toggle
        const themeToggle = document.getElementById("themeToggle");
        const themeIcon = document.querySelector(".theme-icon");
        const savedTheme = localStorage.getItem("theme") || "dark";
        document.body.setAttribute("data-theme", savedTheme);
        themeIcon.textContent = savedTheme === "dark" ? "‚òÄÔ∏è" : "üåô";

        themeToggle.addEventListener("click", () => {
            const currentTheme = document.body.getAttribute("data-theme");
            const newTheme = currentTheme === "dark" ? "light" : "dark";
            document.body.setAttribute("data-theme", newTheme);
            localStorage.setItem("theme", newTheme);
            themeIcon.textContent = newTheme === "dark" ? "‚òÄÔ∏è" : "üåô";
        });

        // Initialize
        window.addEventListener('load', initCanvas);
        window.addEventListener('resize', () => {
            // Save current drawing before resize
            const currentDrawing = canvas.toDataURL();
            initCanvas();

            // Restore drawing after resize
            const img = new Image();
            img.onload = () => {
                ctx.drawImage(img, 0, 0);
            };
            img.src = currentDrawing;
        });
    </script>
</body>

</html>